- Comparable (interface)

	A interface Comparable é uma interface genérica do pacote java.lang do Java que permite que uma classe implemente um método de comparação natural com outras instâncias da mesma classe.

	Quando uma classe implementa a interface Comparable, ela deve implementar um método compareTo() que recebe um objeto do mesmo tipo e retorna um inteiro que indica se o objeto atual é menor, igual ou maior que o objeto recebido como parâmetro. Esse método é usado principalmente para ordenar objetos em coleções, como em um array ou em uma lista.

	Por exemplo, se tivermos uma classe Pessoa com os atributos nome, idade e altura, podemos implementar a interface Comparable para comparar instâncias da classe Pessoa com base na idade. O código seria algo como:

	public class Pessoa implements Comparable<Pessoa> {

	    private String nome;
	    private int idade;
	    private double altura;
	    
	    // Construtor e métodos aqui
	    
	    @Override
	    public int compareTo(Pessoa outraPessoa) {
	        return Integer.compare(this.idade, outraPessoa.idade);
	    }
	}

	Nesse exemplo, o método compareTo() compara duas instâncias da classe Pessoa com base na idade, retornando um valor negativo se a idade da pessoa atual for menor que a idade da outra pessoa, um valor positivo se for maior e zero se forem iguais. Esse método pode então ser usado para ordenar uma lista de pessoas com base na idade:

	List<Pessoa> listaPessoas = new ArrayList<>();
	// adicionar pessoas na lista
	Collections.sort(listaPessoas); // Ordenar lista com base na idade

- Comparator (interface)

	A interface Comparator é uma interface genérica do pacote java.util do Java que permite que uma classe defina um método de comparação personalizado para instâncias de outra classe.

	Ao contrário da interface Comparable, que define uma única maneira natural de comparar objetos, a interface Comparator permite que uma classe defina várias maneiras diferentes de comparar objetos, sem precisar modificar a própria classe. Isso pode ser útil em situações em que não é possível ou desejável alterar a classe que está sendo comparada.

	Quando uma classe implementa a interface Comparator, ela deve implementar um método compare() que recebe dois objetos do tipo que a classe está comparando e retorna um inteiro que indica se o primeiro objeto é menor, igual ou maior que o segundo objeto. Esse método é usado principalmente para ordenar objetos em coleções, como em um array ou em uma lista.

	Por exemplo, se tivermos uma classe Pessoa com os atributos nome, idade e altura, podemos implementar a interface Comparator para comparar instâncias da classe Pessoa com base na altura. O código seria algo como:

	public class PessoaAlturaComparator implements Comparator<Pessoa> {
	    @Override
	    public int compare(Pessoa pessoa1, Pessoa pessoa2) {
	        return Double.compare(pessoa1.getAltura(), pessoa2.getAltura());
	    }
	}

	Nesse exemplo, o método compare() compara duas instâncias da classe Pessoa com base na altura, retornando um valor negativo se a altura da primeira pessoa for menor que a altura da segunda pessoa, um valor positivo se for maior e zero se forem iguais. Esse método pode então ser usado para ordenar uma lista de pessoas com base na altura:

	List<Pessoa> listaPessoas = new ArrayList<>();
	// adicionar pessoas na lista
	PessoaAlturaComparator alturaComparator = new PessoaAlturaComparator();
	Collections.sort(listaPessoas, alturaComparator); // ordenar lista com base na altura

- Default methods

	Default methods (métodos padrão) são métodos definidos em uma interface do Java que fornecem uma implementação padrão (default) para um método. Eles foram introduzidos na versão 8 do Java como uma forma de adicionar novos recursos às interfaces sem quebrar a compatibilidade com versões anteriores.

	Antes da versão 8 do Java, as interfaces só podiam conter assinaturas de método, ou seja, apenas a declaração do método sem uma implementação. Isso significava que qualquer classe que implementasse a interface precisaria fornecer sua própria implementação para todos os métodos da interface.

	Com a introdução de default methods, agora é possível definir uma implementação padrão para um método em uma interface. Isso significa que as classes que implementam a interface podem usar a implementação padrão ou substituí-la por sua própria implementação. Isso permite que novos métodos sejam adicionados a uma interface sem quebrar a compatibilidade com as classes que já a implementam.

	Para declarar um default method em uma interface no Java, você pode simplesmente adicionar a palavra-chave "default" antes da assinatura do método.

	Aqui está um exemplo simples de uma interface com um método padrão:

	public interface Exemplo {
	    default void metodoPadrao() {
	        System.out.println("Este é um método padrão.");
	    }

	    void outroMetodo();
	}

	Neste exemplo, a interface Exemplo tem um método padrão metodoPadrao() que imprime uma mensagem na saída padrão. A interface também tem um método abstrato outroMetodo() que não tem uma implementação padrão e deve ser implementado pelas classes que implementam a interface.

	Uma classe que implementa a interface pode optar por usar a implementação padrão do método metodoPadrao() ou fornecer sua própria implementação. Por exemplo:

	public class ExemploImplementacao implements Exemplo {
	    @Override
	    public void outroMetodo() {
	        System.out.println("Este é outro método.");
	    }
	}

	Nesta implementação da classe ExemploImplementacao, o método outroMetodo() é implementado para imprimir uma mensagem diferente na saída padrão, enquanto o método metodoPadrao() usa a implementação padrão fornecida na interface.

	Os default methods também podem ter parâmetros e retornos como qualquer outro método. Aqui está um exemplo que usa um parâmetro:

	public interface OutraInterface {
	    default int metodoComParametro(int numero) {
	        return numero + 1;
	    }
	}

- Por que usar default methods

	Por exemplo, antes do Java 8 o método sort não existia na interface List, nem em suas mães (Collection e Iterable).

	Será então que simplesmente adicionaram um novo método? Se tivessem feito assim, haveria um grande problema: todas as classes que implementam List parariam de compilar, pois não teriam o método sort. E há muitas, muitas classes que implementam essas interfaces básicas do Java. Há implementações no Hibernate, no Google Collections e muito mais.

	Para evitar essa quebra, o Java 8 optou por criar um novo recurso que possibilitasse adicionar métodos em interfaces e implementá-los ali mesmo! Se você abrir o código fonte da interface List, verá esse método:

		default void sort(Comparator<? super E> c) {
		    Collections.sort(this, c);
		}

	É um default method! Um método de interface que você não precisa implementar na sua classe se não quiser, pois você terá já essa implementação default. Repare que ele simplesmente delega a invocação para o bom e velho Collections.sort, mas veremos que outros métodos fazem muito mais.

	Default methods foi uma forma que o Java encontrou para evoluir interfaces antigas, sem gerar incompatibilidades. Não é uma novidade da linguagem: Scala, C# e outras possuem recursos similares e até mais poderosos. E repare que é diferente de uma classe abstrata: em uma interface você não pode ter atributos de instância, apenas esses métodos que delegam chamadas ou trabalham com os próprios métodos da interface.

- Classes anonimas

	Classes anônimas são uma forma de definir uma classe e instanciá-la ao mesmo tempo, sem precisar declarar explicitamente uma classe separada. Elas são frequentemente usadas para criar objetos que implementam uma interface ou uma classe abstrata de forma rápida e concisa.

	Em Java, uma classe anônima é criada usando a sintaxe new Tipo() { ... }, onde Tipo é a classe ou interface que a classe anônima implementa. A classe anônima deve fornecer uma implementação para todos os métodos abstratos da interface (ou classe abstrata) que está implementando. Também é possível adicionar métodos adicionais à classe anônima, desde que não entrem em conflito com os métodos da interface.

	Aqui está um exemplo simples de como usar uma classe anônima para implementar uma interface:

	// Declaração de interface
	public interface MinhaInterface {
	    void fazerAlgo();
	}

	// Declaração da classe
	public class MinhaClasse {
	    public static void main(String[] args) {

	    	// Declaração da classe anonima
	        MinhaInterface minhaInstancia = new MinhaInterface() {
	            @Override
	            public void fazerAlgo() {
	                System.out.println("Fazendo algo na classe anônima!");
	            }
	        };

	        minhaInstancia.fazerAlgo(); // imprime "Fazendo algo na classe anônima!"
	    }
	}

	Neste exemplo, uma classe anônima é criada para implementar a interface MinhaInterface. A implementação do método fazerAlgo() é fornecida diretamente dentro da classe anônima. A classe anônima é então instanciada e o método fazerAlgo() é chamado na instância resultante. Quando o código é executado, a saída é "Fazendo algo na classe anônima!".

	As classes anônimas podem ser úteis em situações em que é necessário criar uma implementação rápida e simples de uma interface ou classe abstrata, sem precisar definir explicitamente uma classe separada para isso. No entanto, elas podem tornar o código mais difícil de ler e entender, especialmente se forem usadas de forma excessiva.

- Interface funcional

	Uma interface funcional é uma interface que declara exatamente um método abstrato (ou seja, um método sem implementação). Essa interface também pode conter um ou mais métodos padrão (default methods) ou métodos estáticos com implementação. No entanto, o requisito fundamental para que uma interface seja considerada funcional é que ela tenha apenas um método abstrato.

	As interfaces funcionais são frequentemente usadas em programação funcional e em lambda expressions no Java. As expressões lambda permitem que você passe funções como argumentos para outros métodos ou retorne funções como resultados de um método. As interfaces funcionais fornecem o tipo de dados para essas funções, tornando-as uma parte fundamental da programação funcional no Java.

	A interface funcional pode ser anotada com a anotação @FunctionalInterface, que é opcional, mas fortemente recomendada. A anotação @FunctionalInterface ajuda a garantir que a interface atenda ao requisito de ter apenas um método abstrato. Se houver mais de um método abstrato ou nenhum método abstrato na interface, o compilador produzirá um erro de compilação.

	Aqui está um exemplo simples de uma interface funcional:

		@FunctionalInterface
		public interface Calculadora {
		    int calcular(int a, int b);
		}

	Neste exemplo, a interface Calculadora declara um único método abstrato chamado calcular(), que recebe dois inteiros como argumentos e retorna um inteiro como resultado. A interface é anotada com @FunctionalInterface para garantir que ela seja uma interface funcional. As classes que implementam a interface Calculadora devem fornecer uma implementação para o método calcular().

- Expressoes lambda

	As expressões lambda são uma das principais características adicionadas à linguagem Java na versão 8. Elas fornecem uma maneira concisa de criar funções anônimas, ou seja, funções sem nome e que podem ser passadas como argumentos para outras funções ou métodos.

	As expressões lambda são uma forma de implementar interfaces funcionais em Java. Uma interface funcional é uma interface que contém um único método abstrato. Antes das expressões lambda, a maneira padrão de criar uma implementação de uma interface funcional era criar uma classe anônima. As expressões lambda simplificam bastante esse processo, permitindo que você escreva a implementação do método abstrato de uma interface funcional em uma única linha.

	A sintaxe de uma expressão lambda consiste em uma lista de parâmetros entre parênteses, seguida pelo operador "->" e o corpo da expressão lambda. O corpo pode ser uma única expressão ou um bloco de código delimitado por chaves.

	Por exemplo, considere a seguinte interface funcional que representa uma operação binária em dois inteiros:

	interface OperacaoBinaria {
	    int executar(int a, int b);
	}

	Antes das expressões lambda, para criar uma implementação dessa interface, você precisaria criar uma classe anônima, assim:

	OperacaoBinaria soma = new OperacaoBinaria() {
	    public int executar(int a, int b) {
	        return a + b;
	    }
	};

	Com as expressões lambda, você pode escrever a mesma implementação de forma muito mais concisa:

	OperacaoBinaria soma = (a, b) -> a + b;

	Observe que a expressão lambda tem uma lista de parâmetros "(a, b)", que correspondem aos parâmetros do método "executar" da interface funcional. O corpo da expressão lambda "a + b" é a implementação do método.

	As expressões lambda são particularmente úteis em conjunto com as chamadas de método de alta ordem, que são métodos que aceitam outras funções como argumentos. Por exemplo, o método "map" da interface "Stream" em Java 8 permite transformar uma stream de elementos em uma nova stream aplicando uma função a cada elemento. Usando uma expressão lambda, você pode definir facilmente a função de transformação. Por exemplo, o seguinte código aplica a função "toUpperCase" a cada elemento de uma lista de strings:

	List<String> lista = Arrays.asList("apple", "banana", "cherry");
	lista.stream().map(s -> s.toUpperCase()).forEach(System.out::println);

	Em resumo, as expressões lambda são uma característica poderosa adicionada à linguagem Java na versão 8, que permitem criar funções anônimas de forma concisa e expressiva. Elas são particularmente úteis em conjunto com chamadas de método de alta ordem, tornando o código mais legível e fácil de manter.

- Operador ::

	O operador :: é um recurso de sintaxe em Java que é usado para criar Method references, que são uma maneira concisa de referenciar um método existente que pode ser usado como valor de uma expressão lambda ou de um Functional Interface.

	O operador :: é usado para separar o nome do objeto ou da classe do método que estamos referenciando. Dependendo do tipo de Method reference que estamos criando, o operador :: é usado de maneiras diferentes.

- Interface Function

	Em Java, a interface Function é uma das interfaces funcionais mais utilizadas, que define uma função que recebe um argumento de um tipo e produz um resultado de outro tipo.

	A interface Function é definida com o seguinte protótipo:

	public interface Function<T, R> {
	    R apply(T t);
	}

	Nesse protótipo, T é o tipo do argumento da função e R é o tipo de retorno da função. O método apply() é o único método abstrato na interface, que recebe um argumento do tipo T e retorna um valor do tipo R.

	Por exemplo, suponha que temos uma lista de strings e queremos obter uma nova lista de inteiros que represente o comprimento de cada string. Podemos usar a interface Function para criar uma expressão lambda que transforma cada string em seu comprimento:

	List<String> listaDeStrings = Arrays.asList("Olá", "Mundo", "Java");
	Function<String, Integer> comprimentoDaString = s -> s.length();
	List<Integer> listaDeComprimentos = listaDeStrings.stream()
	                                    .map(comprimentoDaString)
	                                    .collect(Collectors.toList());

	Nesse exemplo, estamos criando uma expressão lambda que implementa a interface Function<String, Integer>, que recebe uma string e retorna seu comprimento como um inteiro. Em seguida, estamos usando o método map() para aplicar essa função a cada elemento da lista de strings e produzir uma nova lista de inteiros que representa o comprimento de cada string.

	Em resumo, a interface Function é uma das interfaces funcionais mais utilizadas em Java, que define uma função que recebe um argumento de um tipo e produz um resultado de outro tipo. Ela é frequentemente usada para criar expressões lambda e transformar coleções de dados.

- Method reference

	Em Java, Method references são uma maneira concisa de referenciar um método existente que pode ser usado como valor de uma expressão lambda ou de um Functional Interface.

	Para entender melhor, imagine que temos uma tarefa para realizar em Java, como imprimir algo na tela, realizar uma operação matemática ou realizar uma ação em um objeto específico. Para executar essa tarefa, precisamos chamar um método que já existe em Java para realizar essa tarefa.

	Usar um Method reference significa que, em vez de escrever o código que realiza a tarefa em si, podemos simplesmente referenciar o método existente que já faz o trabalho. Isso é especialmente útil quando usamos expressões lambda ou Functional Interfaces, que esperam um método como argumento.

	Exemplo:

	Suponha que temos uma lista de números inteiros e queremos imprimir cada um deles na tela. Podemos fazer isso usando uma expressão lambda:

	List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5);
	numeros.forEach(numero -> System.out.println(numero));

	Aqui, usamos o método forEach() da classe List para percorrer a lista de números e imprimir cada um deles na tela. A expressão lambda numero -> System.out.println(numero) é uma maneira de definir um comportamento para ser executado para cada elemento da lista.

	No entanto, em vez de usar a expressão lambda, podemos usar um Method Reference para referenciar o método println() da classe System.out. Isso nos permite escrever um código mais conciso e legível:

	List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5);
	numeros.forEach(System.out::println);

	Aqui, estamos passando uma referência ao método println() como argumento para o método forEach(). Observe que o operador :: é usado para separar o nome do objeto ou da classe do método que estamos referenciando.

	Existem quatro tipos de Method references em Java:

	Reference to a static method: referência a um método estático. Nesse caso, usamos o nome da classe que contém o método e o nome do método separados por ::. Por exemplo, para referenciar o método estático parseInt() da classe Integer, podemos usar Integer::parseInt.

	Reference to an instance method of an object of a particular class: referência a um método de instância de um objeto de uma classe específica. Nesse caso, usamos o nome do objeto seguido de :: e o nome do método. Por exemplo, para referenciar o método length() da classe String, podemos usar String::length.

	Reference to an instance method of an existing object: referência a um método de instância de um objeto existente. Nesse caso, usamos o nome do objeto seguido de :: e o nome do método. Por exemplo, para referenciar o método println() do objeto System.out, podemos usar System.out::println.

	Reference to a constructor: referência a um construtor. Nesse caso, usamos o nome da classe seguido de ::new. Por exemplo, para referenciar o construtor da classe ArrayList, podemos usar ArrayList::new.

- Métodos estaticos de interface

	A partir do Java 8, é possível definir métodos estáticos em interfaces em Java. Esses métodos são chamados de "métodos estáticos de interface" e são implementados diretamente na interface, sem precisar de uma implementação em uma classe concreta que implementa a interface.

	Os métodos estáticos de interface são úteis quando queremos fornecer métodos utilitários que não dependem do estado de um objeto. Por exemplo, podemos definir um método estático em uma interface para converter um valor de um tipo para outro, sem precisar criar uma nova classe utilitária para isso.

	Para definir um método estático em uma interface, usamos a palavra-chave static antes da definição do método. Aqui está um exemplo simples:

	public interface MinhaInterface {
	    static int dobro(int x) {
	        return x * 2;
	    }
	}

	Nesse exemplo, estamos definindo um método estático chamado dobro() na interface MinhaInterface, que simplesmente retorna o dobro do argumento x.

	Podemos chamar o método estático de interface usando a sintaxe NomeDaInterface.nomeDoMetodo(). Por exemplo, podemos chamar o método dobro() da interface MinhaInterface da seguinte maneira:

	int resultado = MinhaInterface.dobro(5);

	Em resumo, os métodos estáticos de interface em Java são métodos definidos diretamente em uma interface, usando a palavra-chave static. Esses métodos são úteis para fornecer métodos utilitários que não dependem do estado de um objeto e podem ser chamados usando a sintaxe NomeDaInterface.nomeDoMetodo().

- Interface Stream

	As Streams em Java são uma das principais características introduzidas na versão 8 da linguagem. Elas permitem uma maneira mais concisa, funcional e eficiente de processar coleções de dados.

	Uma Stream é uma sequência de elementos que pode ser processada de forma paralela ou serial. Ela não armazena dados, mas em vez disso, é criada a partir de uma fonte de dados, como uma coleção, matriz ou arquivo, e processa seus elementos em tempo real. As modificações em um stream não modificam a coleção/objeto que o gerou. Tudo que é feito nesse fluxo de objetos, nesse Stream, não impacta, não tem efeitos colaterais na coleção original. 

	Existem dois tipos de Streams em Java: as Streams de objetos e as Streams primitivas. As Streams de objetos lidam com objetos Java e suportam uma variedade de tipos, incluindo List, Set, Map e até mesmo Streams aninhadas. As Streams primitivas lidam com tipos primitivos Java, como int, long e double, e fornecem operações especializadas para eles.

	As Streams oferecem vários métodos de operação, como filter, map, reduce e collect, que permitem que os desenvolvedores processem, filtre, transformem e reduzam os elementos da Stream. Essas operações são encadeadas em uma pipeline, onde a saída de uma operação é a entrada da próxima operação. Isso permite que as operações sejam compostas e executadas em uma única passagem pelos elementos da Stream.

	As Streams também suportam operações de paralelismo, onde o processamento pode ser dividido entre vários núcleos de CPU para processar grandes conjuntos de dados com maior eficiência. No entanto, é importante lembrar que a paralelização nem sempre é mais rápida do que a serialização, e que a decisão de usar ou não paralelismo deve ser cuidadosamente avaliada de acordo com o contexto.

	As Streams foram introduzidas na plataforma Java 8 como uma maneira mais eficiente e concisa de processar coleções de dados em comparação com abordagens tradicionais, como loops for. Desde então, elas se tornaram uma parte essencial da biblioteca padrão do Java e são usadas em muitos aplicativos e bibliotecas Java.

- Detalhes dos dois tipos de Stream

	Em Java, existem dois tipos de Streams: as Streams de objetos e as Streams primitivas.

	As Streams de objetos lidam com objetos Java e suportam uma variedade de tipos, incluindo List, Set, Map e até mesmo Streams aninhadas. Elas têm o tipo genérico "Stream<T>", onde "T" é o tipo de objeto que a Stream manipula.

	Por exemplo, se você tiver uma lista de strings, você pode criar uma Stream a partir dela da seguinte forma:

	List<String> lista = Arrays.asList("maçã", "banana", "laranja");
	Stream<String> stream = lista.stream();

	As Streams primitivas lidam com tipos primitivos Java, como int, long e double, e fornecem operações especializadas para eles. Elas têm tipos específicos, como "IntStream", "LongStream" e "DoubleStream".

	Por exemplo, se você tiver um array de inteiros, você pode criar uma IntStream a partir dele da seguinte forma:

	int[] numeros = {1, 2, 3, 4, 5};
	IntStream stream = Arrays.stream(numeros);

	Os métodos de operação e as funcionalidades disponíveis são semelhantes para ambas as Streams, mas as Streams primitivas têm algumas operações especializadas para trabalhar com tipos primitivos e são geralmente mais eficientes do que as Streams de objetos.

- Métodos de instancia da interface Stream

	allMatch(Predicate<? super T> predicate) - Retorna se todos os elementos deste fluxo correspondem ao predicado fornecido.

	anyMatch(Predicate<? super T> predicate) - Retorna se algum elemento deste fluxo corresponde ao predicado fornecido.

	collect(Collector<? super T,A,R> collector) - Executa uma operação de redução mutável nos elementos deste fluxo usando um Coletor.

	collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner) - Executa uma operação de redução mutável nos elementos deste fluxo.

	count() - Retorna a contagem de elementos neste fluxo.

	distinct() - Retorna um fluxo que consiste nos elementos distintos (de acordo com Object.equals(Object)) desse fluxo.

	filter(Predicate<? super T> predicate) - Retorna um fluxo que consiste nos elementos desse fluxo que correspondem ao predicado fornecido.

	findAny() - Retorna um Optional descrevendo algum elemento do stream ou um Optional vazio, se o stream estiver vazio.

	findFirst() - Retorna um Optional descrevendo o primeiro elemento deste stream ou um Optional vazio, se o stream estiver vazio.

	flatMap(Function<? super T,? extends Stream<? extends R>> mapper) - Retorna um fluxo que consiste nos resultados da substituição de cada elemento desse fluxo pelo conteúdo de um fluxo mapeado produzido pela aplicação da função de mapeamento fornecida a cada elemento.

	flatMapToDouble(Function<? super T,? extends DoubleStream> mapper) - Retorna um DoubleStream consistindo nos resultados da substituição de cada elemento desse stream pelo conteúdo de um stream mapeado produzido pela aplicação da função de mapeamento fornecida a cada elemento.

	flatMapToInt(Function<? super T,? extends IntStream> mapper) - Retorna um IntStream consistindo nos resultados da substituição de cada elemento desse stream pelo conteúdo de um stream mapeado produzido pela aplicação da função de mapeamento fornecida a cada elemento.

	flatMapToLong(Function<? super T,? extends LongStream> mapper) - Retorna um LongStream consistindo nos resultados da substituição de cada elemento desse stream pelo conteúdo de um stream mapeado produzido pela aplicação da função de mapeamento fornecida a cada elemento.

	forEach(Consumer<? super T> action) - Executa uma ação para cada elemento deste fluxo.

	forEachOrdered(Consumer<? super T> action) - Executa uma ação para cada elemento deste fluxo, na ordem de encontro do fluxo se o fluxo tiver uma ordem de encontro definida.

	limit(long maxSize) - Retorna um stream que consiste nos elementos desse stream, truncados para não ultrapassar maxSize de comprimento.

	map(Function<? super T,? extends R> mapper) - Retorna um fluxo que consiste nos resultados da aplicação da função fornecida aos elementos desse fluxo.

	mapToDouble(ToDoubleFunction<? super T> mapper) - Retorna um DoubleStream consistindo nos resultados da aplicação da função dada aos elementos deste stream.

	mapToInt(ToIntFunction<? super T> mapper) - Retorna um IntStream consistindo nos resultados da aplicação da função dada aos elementos deste stream.

	mapToLong(ToLongFunction<? super T> mapper) - Retorna um LongStream consistindo nos resultados da aplicação da função dada aos elementos deste stream.

	max(Comparator<? super T> comparator) - Retorna o elemento máximo deste stream de acordo com o Comparator fornecido.

	min(Comparator<? super T> comparator) - Retorna o elemento mínimo deste stream de acordo com o Comparator fornecido.

	noneMatch(Predicate<? super T> predicate) - Retorna se nenhum elemento deste fluxo corresponde ao predicado fornecido.

	peek(Consumer<? super T> action) - Retorna um fluxo que consiste nos elementos desse fluxo, executando adicionalmente a ação fornecida em cada elemento à medida que os elementos são consumidos do fluxo resultante.

	reduce(BinaryOperator<T> accumulator) - Realiza uma redução nos elementos desse fluxo, usando uma função de acumulação associativa, e retorna um Opcional descrevendo o valor reduzido, se houver.

	reduce(T identity, BinaryOperator<T> accumulator) - Realiza uma redução nos elementos desse fluxo, usando o valor de identidade fornecido e uma função de acumulação associativa, e retorna o valor reduzido.

	reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner) - Realiza uma redução nos elementos deste fluxo, usando as funções de identidade, acumulação e combinação fornecidas.

	skip(long n) - Retorna um fluxo que consiste nos elementos restantes desse fluxo após descartar os primeiros n elementos do fluxo.

	sorted() - Retorna um fluxo que consiste nos elementos desse fluxo, classificados de acordo com a ordem natural.

	sorted(Comparator<? super T> comparator) - Retorna um stream que consiste nos elementos desse stream, classificados de acordo com o Comparator fornecido.

	toArray() - Retorna um array contendo os elementos deste stream.

	toArray(IntFunction<A[]> generator) - Retorna uma matriz contendo os elementos desse stream, usando a função geradora fornecida para alocar a matriz retornada, bem como quaisquer matrizes adicionais que possam ser necessárias para uma execução particionada ou para redimensionamento.

- Exemplos basicos de uso de Streams

	Filtrando elementos de uma lista:

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		List<Integer> numerosPares = numeros.stream()
		                                     .filter(n -> n % 2 == 0)
		                                     .collect(Collectors.toList());
		System.out.println(numerosPares); // Saída: [2, 4, 6, 8, 10]

		Este código cria uma lista de números, filtra apenas os números pares usando o método filter(), e armazena o resultado em outra lista usando o método collect().

	Transformando elementos de uma lista:

		List<String> frutas = Arrays.asList("maçã", "banana", "laranja");
		List<String> frutasMaiusculas = frutas.stream()
		                                      .map(String::toUpperCase)
		                                      .collect(Collectors.toList());
		System.out.println(frutasMaiusculas); // Saída: [MAÇÃ, BANANA, LARANJA]

		Este código cria uma lista de frutas, transforma todas as frutas para maiúsculas usando o método map(), e armazena o resultado em outra lista usando o método collect().

	Reduzindo uma lista de elementos:

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5);
		int soma = numeros.stream().reduce(0, (a, b) -> a + b);
		System.out.println(soma); // Saída: 15

		Este código cria uma lista de números, e então usa o método reduce() para somar todos os elementos da lista.

	Encontrando o primeiro elemento de uma lista que satisfaz uma condição:

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		Optional<Integer> primeiroPar = numeros.stream()
		                                        .filter(n -> n % 2 == 0)
		                                        .findFirst();
		System.out.println(primeiroPar); // Saída: Optional[2]

		Este código cria uma lista de números, filtra apenas os números pares usando o método filter(), e então encontra o primeiro número par usando o método findFirst(). O resultado é armazenado em um objeto Optional, que pode ser vazio caso não haja nenhum número par na lista.

	Verificando se todos os elementos de uma lista satisfazem uma condição:

		List<Integer> numeros = Arrays.asList(2, 4, 6, 8, 10);
		boolean todosPares = numeros.stream()
		                             .allMatch(n -> n % 2 == 0);
		System.out.println(todosPares); // Saída: true

		Este código cria uma lista de números pares, e verifica se todos eles são pares usando o método allMatch(). O resultado é armazenado em uma variável booleana.

	Calculando a média de uma lista de números:

		List<Integer> numeros = Arrays.asList(1, 2, 3, 4, 5);
		OptionalDouble media = numeros.stream()
		                              .mapToInt(Integer::intValue)
		                              .average();
		System.out.println(media); // Saída: OptionalDouble[3.0]

		Este código cria uma lista de números, converte cada um deles para um tipo primitivo int usando o método mapToInt(), e então calcula a média usando o método average(). O resultado é armazenado em um objeto OptionalDouble, que pode ser vazio caso a lista esteja vazia.

- Classe Optional

	A classe Optional é uma classe introduzida no Java 8 que representa um objeto que pode conter ou não um valor. Ela foi criada para evitar problemas de null pointer exception e tornar o código mais robusto e legível.

	Em vez de retornar um valor nulo, um método pode retornar um objeto Optional que encapsula o valor de retorno, ou um valor nulo se não houver valor a ser retornado. Isso obriga o código que consome o valor a verificar se ele está presente ou não antes de tentar usá-lo, evitando assim exceções de null pointer.

	A classe Optional possui métodos úteis para verificar a presença de um valor, extrair o valor encapsulado ou retornar um valor padrão se não houver valor presente. Alguns exemplos de uso da classe Optional são:

		Optional<String> valor = Optional.of("valor presente");

		// verifica se o valor está presente
		if (valor.isPresent()) {
		    System.out.println(valor.get());
		}

		// retorna um valor padrão se não houver valor presente
		String valorOuPadrao = valor.orElse("valor padrão");
		System.out.println(valorOuPadrao);

		// retorna o valor encapsulado ou lança uma exceção se não houver valor presente
		String valorObrigatorio = valor.orElseThrow(() -> new RuntimeException("Valor obrigatório não presente"));
		System.out.println(valorObrigatorio);

	A classe Optional é uma forma elegante e segura de lidar com valores nulos e evitar exceções de null pointer. No entanto, é importante lembrar que seu uso deve ser ponderado e não deve ser exagerado. A classe Optional não é uma solução para todos os problemas relacionados a valores nulos e pode tornar o código mais complexo em alguns casos.

- Classe Collectors

	A classe Collectors é uma classe utilitária introduzida no Java 8 que fornece métodos estáticos para criar coletores usados em operações de coleta de elementos em coleções ou arrays.

	Um colecionador é um objeto que define uma operação de redução que pode ser usada para coletar os elementos de uma sequência em um único resultado, como uma lista, um conjunto, um mapa ou um valor primitivo. O colecionador pode ser usado em conjunto com as operações de fluxo da classe Stream, como filter, map, flatMap, distinct, entre outras.

	A classe Collectors fornece vários coletores prontos para uso, como toList(), que coleta os elementos de um fluxo em uma lista, ou toSet(), que coleta os elementos de um fluxo em um conjunto. Alguns exemplos de uso da classe Collectors são:

		List<String> lista = Arrays.asList("um", "dois", "três");

		// coleta os elementos em uma lista
		List<String> resultado1 = lista.stream()
		                               .filter(s -> s.length() == 3)
		                               .collect(Collectors.toList());

		// coleta os elementos em um conjunto
		Set<String> resultado2 = lista.stream()
		                              .filter(s -> s.length() == 3)
		                              .collect(Collectors.toSet());

		// coleta os elementos em um mapa
		Map<String, Integer> resultado3 = lista.stream()
		                                       .filter(s -> s.length() == 3)
		                                       .collect(Collectors.toMap(s -> s, s -> s.length()));

	Esses são apenas alguns exemplos de coletores disponíveis na classe Collectors. A classe também fornece coletores para calcular médias, somas, valores máximos e mínimos, entre outras operações de redução. O uso da classe Collectors torna o código mais conciso e legível, permitindo que as operações de coleta de elementos sejam feitas de forma elegante e eficiente.

- Datas

	LocalDate

		A classe LocalDate é uma classe do pacote java.time introduzida no Java 8 que representa uma data sem informação de horário. Ela é imutável e pode ser usada para realizar operações de manipulação de datas, como adicionar ou subtrair dias, meses ou anos.

		A classe LocalDate armazena uma data no formato ISO-8601 (yyyy-MM-dd), com precisão de dia. Ela é independente de fuso horário e não contém informações sobre horário ou fuso horário.

		A classe LocalDate fornece métodos para criar objetos LocalDate a partir de uma string no formato ISO-8601 ou de valores numéricos para ano, mês e dia.

		Exemplos:

			// cria um objeto LocalDate para a data atual
			LocalDate hoje = LocalDate.now();

			// cria um objeto LocalDate para uma data específica
			LocalDate data = LocalDate.of(2023, 3, 10);

			// Criação de um objeto LocalDate a partir de uma string no formato ISO-8601
			LocalDate data = LocalDate.parse("2023-03-10");

			// Criação de um objeto LocalDate a partir de uma string no formato "dd/MM/yyyy"
			LocalDate data = LocalDate.parse("10/03/2023", DateTimeFormatter.ofPattern("dd/MM/yyyy"));

			// Obtenção dos valores numéricos de ano, mês e dia de uma data
			int ano = data.getYear();
			int mes = data.getMonthValue();
			int dia = data.getDayOfMonth();

			// Cálculo da diferença de dias entre duas datas
			LocalDate outraData = LocalDate.of(2023, 3, 1);
			long diferenca = ChronoUnit.DAYS.between(outraData, data);

			// Cálculo de uma data a partir de outra, adicionando ou subtraindo dias, meses ou anos
			LocalDate dataDaquiUmDia = data.plusDays(1);
			LocalDate dataDaquiUmMes = data.plusMonths(1);
			LocalDate dataDaquiUmAno = data.plusYears(1);
			LocalDate dataHaUmDia = data.minusDays(1);
			LocalDate dataHaUmMes = data.minusMonths(1);
			LocalDate dataHaUmAno = data.minusYears(1);

			// Verificação se uma data é anterior, posterior ou igual a outra
			LocalDate outraData = LocalDate.of(2023, 3, 1);
			boolean dataAntes = data.isBefore(outraData);
			boolean dataDepois = data.isAfter(outraData);
			boolean datasIguais = data.equals(outraData);

			// Verificação se uma data é um ano bissexto
			boolean anoBissexto = data.isLeapYear();

			// Cálculo da diferença de dias entre duas datas
			long diferencaDias = ChronoUnit.DAYS.between(outraData, data);

	LocalDateTime

		A classe LocalDateTime é uma classe do pacote java.time introduzida no Java 8 que representa uma data e hora sem informação de fuso horário. Ela é imutável e pode ser usada para realizar operações de manipulação de datas e horários, como adicionar ou subtrair dias, meses, anos, horas, minutos e segundos.

		A classe LocalDateTime armazena uma data e hora no formato ISO-8601 (yyyy-MM-ddTHH:mm:ss), com precisão de segundos. Ela é independente de fuso horário e não contém informações sobre fuso horário.

		A classe LocalDateTime fornece métodos para criar objetos LocalDateTime a partir de uma string no formato ISO-8601 ou de valores numéricos para ano, mês, dia, hora, minuto e segundo. 

		Exemplos:

			// cria um objeto LocalDateTime para a data e hora atual
			LocalDateTime agora = LocalDateTime.now();

			// cria um objeto LocalDateTime para uma data e hora específicas
			LocalDateTime dataHora = LocalDateTime.of(2023, 3, 10, 10, 30, 0);

			// Criação de um objeto LocalDateTime a partir de uma string no formato ISO-8601
			LocalDateTime dataHora = LocalDateTime.parse("2023-03-10T10:30:00");

			// Criação de um objeto LocalDateTime a partir de uma string no formato "dd/MM/yyyy HH:mm:ss"
			LocalDateTime data = LocalDateTime.parse("10/03/2023 21:42:08", DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss"));

			// Obtenção dos valores numéricos de ano, mês, dia, hora, minuto e segundo de uma data
			int ano = data.getYear();
			int mes = data.getMonthValue();
			int dia = data.getDayOfMonth();
			int hora = data.getHour();
			int minuto = data.getMinute();
			int segundo = data.getSecond();

			// Cálculo da diferença de dias entre duas datas
			LocalDateTime data1 = LocalDateTime.of(2022, 1, 1, 0, 0, 0);
			LocalDateTime data2 = LocalDateTime.of(2022, 2, 1, 0, 0, 0);
			long diferencaEmDias = ChronoUnit.DAYS.between(data1, data2);

			// Cálculo de uma data a partir de outra, adicionando ou subtraindo dias, meses ou anos
			LocalDateTime dataDaquiUmDia = data.plusDays(1);
			LocalDateTime dataDaquiUmMes = data.plusMonths(1);
			LocalDateTime dataDaquiUmAno = data.plusYears(1);
			LocalDateTime dataDaquiUmaHora = data.plusHours(1);
			LocalDateTime dataDaquiUmMinuto = data.plusMinutes(1);
			LocalDateTime dataDaquiUmSegundo = data.plusSeconds(1);
			LocalDateTime dataHaUmDia = data.minusDays(1);
			LocalDateTime dataHaUmMes = data.minusMonths(1);
			LocalDateTime dataHaUmAno = data.minusYears(1);
			LocalDateTime dataHaUmaHora = data.minusHours(1);
			LocalDateTime dataHaUmMinuto = data.minusMinutes(1);
			LocalDateTime dataHaUmSegundo = data.minusSeconds(1);

			// Verificação se uma data é anterior, posterior ou igual a outra
			LocalDateTime outraData = LocalDateTime.of(2022, 1, 1, 0, 0, 0);
			boolean dataAntes = data.isBefore(outraData);
			boolean dataDepois = data.isAfter(outraData);
			boolean datasIguais = data.equals(outraData);

			// Verificação se uma data é um ano bissexto
			boolean anoBissexto = data.isLeapYear();

			// Cálculo da diferença de dias entre duas datas
			long diferencaDias = ChronoUnit.DAYS.between(outraData, data);

			// Criação de um objeto LocalDateTime a partir de um objeto LocalDate e um objeto LocalTime
			LocalDate data = LocalDate.of(2023, 3, 10);
			LocalTime hora = LocalTime.of(10, 30);
			LocalDateTime dataHora2 = LocalDateTime.of(data, hora);

	LocalTime

		A classe LocalTime faz parte do pacote java.time do Java 8 em diante, e representa um horário local, sem considerar informações de data ou fuso horário. Ela armazena as informações de hora, minuto, segundo e frações de segundo em um objeto imutável.

		Com a classe LocalTime, é possível realizar operações aritméticas simples como adição, subtração, comparação e diferença entre horários, bem como formatar e analisar objetos de horário com a classe DateTimeFormatter.

		Exemplos:

			// Criar um objeto LocalTime a partir de valores de hora, minuto e segundo
			LocalTime horario = LocalTime.of(15, 30, 45);

			// Obter os valores de hora, minuto e segundo de um objeto LocalTime
			int hora = horario.getHour();
			int minuto = horario.getMinute();
			int segundo = horario.getSecond();

			// Adicionar ou subtrair uma quantidade de tempo em um objeto LocalTime
			LocalTime horarioAdiantado = horario.plusMinutes(15)
			LocalTime horarioAtrasado = horario.minusHours(2)

			// Comparar dois objetos LocalTime
			LocalTime horario1 = LocalTime.of(9, 0, 0);
			LocalTime horario2 = LocalTime.of(10, 0, 0);
			boolean antes = horario1.isBefore(horario2); // true
			boolean depois = horario1.isAfter(horario2); // false
			boolean igual = horario1.equals(horario2); // false

			// Formatar um objeto LocalTime em uma string
			String horarioFormatado = horario.format(DateTimeFormatter.ofPattern("HH:mm:ss"));
			System.out.println(horarioFormatado);

		A classe LocalTime é muito útil em situações em que precisamos trabalhar somente com informações de horário, sem se preocupar com datas ou fusos horários.

	DateTimeFormater

		A classe DateTimeFormatter é uma classe do pacote java.time.format do Java 8 em diante, que é utilizada para formatar e analisar objetos de data e hora.

		Ela é responsável por transformar um objeto de data/hora em uma string formatada e vice-versa. Através de padrões de formatação, é possível definir como a data/hora deve ser apresentada.

		O DateTimeFormatter é uma classe imutável que oferece diversos métodos para formatar e analisar datas/horas. Alguns dos métodos mais comuns são: ofPattern, que cria um objeto DateTimeFormatter com um padrão de formatação especificado; format, que formata um objeto de data/hora em uma string; e parse, que analisa uma string formatada em um objeto de data/hora.

		A classe DateTimeFormatter é muito útil para aplicações que precisam exibir informações de data e hora de forma legível para o usuário, permitindo que sejam apresentados de acordo com o formato desejado em diferentes regiões ou culturas.

		Exemplos:

			// Criando um objeto DateTimeFormatter a partir de um padrão de formatação
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");

			Neste exemplo, estamos criando um objeto DateTimeFormatter a partir do padrão de formatação "dd/MM/yyyy", que indica que queremos formatar datas no formato "dia/mês/ano".

			// Formatando uma data com o objeto DateTimeFormatter
			LocalDate data = LocalDate.now();
			String dataFormatada = formatter.format(data);

			Neste exemplo, estamos criando um objeto LocalDate com a data atual e formatando a data em uma string utilizando o objeto DateTimeFormatter criado anteriormente.

			// Analisando uma string em uma data com o objeto DateTimeFormatter
			String dataString = "20/03/2023";
			LocalDate data = LocalDate.parse(dataString, formatter);

			Neste exemplo, estamos analisando a string "20/03/2023" em um objeto LocalDate utilizando o objeto DateTimeFormatter criado anteriormente.

			// Criando um objeto DateTimeFormatter com múltiplos padrões de formatação
			DateTimeFormatter formatter = new DateTimeFormatterBuilder()
			        .appendOptional(DateTimeFormatter.ofPattern("dd/MM/yyyy"))
			        .appendOptional(DateTimeFormatter.ofPattern("yyyy-MM-dd"))
			        .toFormatter();

			Neste exemplo, estamos criando um objeto DateTimeFormatter com dois padrões de formatação opcionais ("dd/MM/yyyy" e "yyyy-MM-dd"). Dessa forma, o objeto DateTimeFormatter pode analisar datas em ambos os formatos.

			// Formatando um horário com o objeto DateTimeFormatter
			LocalTime horario = LocalTime.now();
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");
			String horarioFormatado = formatter.format(horario);
			System.out.println(horarioFormatado);

			Neste exemplo, estamos criando um objeto LocalTime com o horário atual e formatando o horário em uma string utilizando o objeto DateTimeFormatter com o padrão "HH:mm:ss", que indica que queremos formatar o horário com horas, minutos e segundos.

			// Analisando uma string em um horário com o objeto DateTimeFormatter
			String horarioString = "15:30:00";
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");
			LocalTime horario = LocalTime.parse(horarioString, formatter);
			System.out.println(horario);

			Neste exemplo, estamos analisando a string "15:30:00" em um objeto LocalTime utilizando o objeto DateTimeFormatter com o padrão "HH:mm:ss".

	ChronoUnit

		A classe ChronoUnit é uma classe de enumeração em Java que representa as unidades de tempo suportadas pelo pacote java.time, introduzido no Java 8 para lidar com datas e horários. Essa classe define as seguintes constantes enumeradas:

		NANOS: representa a unidade de tempo de nanossegundos.
		MICROS: representa a unidade de tempo de microssegundos.
		MILLIS: representa a unidade de tempo de milissegundos.
		SECONDS: representa a unidade de tempo de segundos.
		MINUTES: representa a unidade de tempo de minutos.
		HOURS: representa a unidade de tempo de horas.
		HALF_DAYS: representa a unidade de tempo de meio dia.
		DAYS: representa a unidade de tempo de dias.
		WEEKS: representa a unidade de tempo de semanas.
		MONTHS: representa a unidade de tempo de meses.
		YEARS: representa a unidade de tempo de anos.
		DECADES: representa a unidade de tempo de décadas.
		CENTURIES: representa a unidade de tempo de séculos.
		MILLENNIA: representa a unidade de tempo de milênios.
		ERAS: representa a unidade de tempo de eras.
		Essas constantes são usadas para calcular a diferença entre duas datas ou horários em diferentes unidades de tempo. Por exemplo, podemos usar a constante DAYS para calcular a diferença entre duas datas em dias.

		Exemplo:

			LocalDate data1 = LocalDate.of(2023, 3, 15);
			LocalDate data2 = LocalDate.of(2023, 3, 10);
			long diferencaEmDias = ChronoUnit.DAYS.between(data2, data1);
			System.out.println("A diferença entre as datas é de " + diferencaEmDias + " dias.");

			Neste exemplo, estamos usando o método between da classe ChronoUnit para calcular a diferença entre as datas data1 e data2 em dias. O resultado é armazenado na variável diferencaEmDias e é impresso na saída padrão.

			No lugar de "DAYS" pdoeriamos ter uilizado qualquer outro ENUM da classe.

	Instant

		Em Java, a classe Instant representa um ponto na linha do tempo (uma posição na escala de tempo UTC). Em outras palavras, é uma representação de um instante específico no tempo, que pode ser utilizado para medir a diferença entre dois eventos.

		A classe Instant é uma classe simples e eficiente, projetada para ser imutável e thread-safe. Ela armazena a quantidade de segundos e nanossegundos desde o Unix Epoch (1 de janeiro de 1970, meia-noite UTC) em um número inteiro de 64 bits, o que permite fácil conversão para e de outras representações de tempo.

		Podemos criar um objeto Instant de várias maneiras diferentes. Por exemplo, podemos obter a data e hora atual em UTC utilizando o método estático now():

			Instant agora = Instant.now();

		Também podemos criar um objeto Instant a partir de um valor numérico de segundos e nanossegundos desde o Epoch:

			Instant epoch = Instant.ofEpochSecond(0);

		A classe Instant também fornece vários métodos úteis para manipular e comparar pontos no tempo. Por exemplo, podemos adicionar ou subtrair uma quantidade de tempo em segundos ou nanossegundos utilizando os métodos plusSeconds(), minusNanos(), etc.:

			Instant agora = Instant.now();
			Instant daquiUmaHora = agora.plusSeconds(3600);

		Podemos comparar dois objetos Instant utilizando os métodos isBefore(), isAfter() e equals():

			Instant inicio = Instant.ofEpochSecond(0);
			Instant agora = Instant.now();

			if (agora.isAfter(inicio)) {
			    System.out.println("A data atual é posterior ao Epoch.");
			}

		Em resumo, a classe Instant é uma maneira simples e eficiente de representar e manipular pontos no tempo em Java, especialmente em cenários que envolvem comparações, cálculos e operações com diferentes fusos horários e representações de data e hora.

	ZonedDateTime

		A classe ZonedDateTime é uma classe do pacote java.time introduzida no Java 8, que representa uma data e hora com informações completas de fuso horário (offset em relação ao UTC ou um identificador de fuso horário). Ela é utilizada para representar um ponto específico no tempo em um determinado fuso horário, e também permite a conversão entre diferentes fusos horários.

		Um objeto ZonedDateTime é criado a partir de um objeto LocalDateTime e um objeto ZoneId, que representa um fuso horário. Podemos criar um objeto ZonedDateTime de várias maneiras, por exemplo:

			// Criando a partir de um LocalDateTime e um ZoneId
			LocalDateTime dateTime = LocalDateTime.of(2023, 3, 11, 12, 0);
			ZoneId zone = ZoneId.of("America/Sao_Paulo");
			ZonedDateTime zonedDateTime = ZonedDateTime.of(dateTime, zone);

			// Criando a partir de um Instant e um ZoneId
			Instant instant = Instant.now();
			ZonedDateTime zonedDateTime = instant.atZone(zone);

		A classe ZonedDateTime fornece vários métodos úteis para manipular e obter informações sobre datas e horas em um determinado fuso horário.

		Por exemplo, podemos adicionar ou subtrair uma quantidade de tempo em horas, minutos ou segundos utilizando os métodos plusHours(), minusMinutes(), etc.:

			ZonedDateTime agora = ZonedDateTime.now();
			ZonedDateTime daquiUmaHora = agora.plusHours(1);

		Também podemos obter informações sobre o fuso horário utilizando os métodos getZone() e getOffset(), que retornam o objeto ZoneId e o offset em relação ao UTC, respectivamente. Além disso, podemos converter um objeto ZonedDateTime para um Instant utilizando o método toInstant():

			ZonedDateTime agora = ZonedDateTime.now();
			ZoneId zone = ZoneId.of("America/Sao_Paulo");
			Instant instant = agora.toInstant();

		Em resumo, a classe ZonedDateTime é uma maneira conveniente de representar e manipular datas e horas com informações completas de fuso horário em Java, permitindo a realização de cálculos e operações em diferentes fusos horários.
